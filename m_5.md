# M5: Portfolio Construction (Overlapping K‑Month Holding, Long‑Only)

## Purpose
Turn monthly momentum signals into investable, long‑only portfolios using overlapping K‑month holding cohorts. Produce deterministic, reproducible target weights and trades for downstream cost/execution modeling and backtesting.

## Objectives
- Construct monthly long‑only winner portfolios with K‑month overlapping cohorts.
- Select winners via decile (default: D10) or top‑quantile threshold.
- Equal‑weight within each cohort; target each cohort weight = 1/K.
- Renormalize within a cohort when names drop (halts, ineligibility) without reassigning weight across cohorts.
- Emit holdings and trades tables; keep logic calendar‑aware and leak‑free.

## Scope
- In‑scope: winner selection, cohorting, monthly rebalances, weights, trades, I/O, config + validation, tests, docs, optional CLI.
- Out‑of‑scope: transaction costs, slippage/impact, execution price selection, PnL simulation (M6+).

---

## Inputs and Outputs

### Inputs
- `data/clean/momentum.parquet` (from M4): monthly signal table with columns at minimum:
  - `month_end` (datetime64[ns])
  - `ticker` (str)
  - `momentum` (float)
  - `valid` (bool)
  - `decile` (Int64, 1..10) and/or `pct_rank` (float in [0,1])
- `config/data.yml` additions (validated via Pydantic):
  - `portfolio.k_months` (int, default `6`, `>=1`).
  - `portfolio.selection` (str enum: `top_decile` | `top_quantile`, default `top_decile`).
  - `portfolio.long_decile` (int, default `10`, only if `selection=top_decile`).
  - `portfolio.top_quantile` (float in (0,1], default `0.1`, only if `selection=top_quantile`, uses `pct_rank >= 1 - top_quantile`).
  - `portfolio.renormalize_within_cohort` (bool, default `true`).
  - `portfolio.redistribute_across_cohorts` (bool, default `false`).
  - `portfolio.exclude_on_missing_price` (bool, default `true`).
  - `portfolio.calendar` (optional; default inherit `signals.momentum.calendar`).

Notes
- If separate `config/strategy.yml` is introduced later, mirror these fields there; for now, support `config/data.yml` for tests and simplicity.

### Outputs
- Parquet: `data/clean/portfolio_holdings.parquet` with monthly target weights:
  - `month_end` (datetime64[ns])
  - `ticker` (str)
  - `weight` (float in [0,1])
  - `cohort_start` (datetime64[ns]; formation month of cohort)
  - `age_months` (int; 0..K‑1 at month t)
  - `cohort_id` (int; rolling id 0..K‑1 by `cohort_start % K`)
  - `n_names_in_cohort` (int; after exclusions, per month)
  - `n_active_cohorts` (int; per month)
- Parquet (optional): `data/clean/portfolio_trades.parquet` with one row per `month_end,ticker`:
  - `prev_weight`, `target_weight`, `trade_dW` (delta), `side` (`buy`|`sell`|`none`)
- CSV (optional): `data/clean/portfolio_summary.csv` per `month_end`:
  - `n_active_cohorts`, `n_holdings`, `gross_turnover` (0.5 * sum |dW|), `cash_weight` (if <K cohorts active or empty cohort).

---

## Algorithm Details
1. Winner selection (formation at month t)
   - Filter to rows with `valid=true` at month t.
   - If `selection=top_decile`: keep `decile == long_decile` (default 10). If `decile` is NaN or group below minimum names in M4, no cohort is formed for that month.
   - If `selection=top_quantile`: keep `pct_rank >= 1 - top_quantile` among valid names.
   - Let `W_t` be the selected tickers at t; `n_t = |W_t|`.
2. New cohort weights at t
   - If `n_t > 0`, create cohort `C_t` with target cohort weight `wC = 1/K`.
   - Per‑name target within cohort: `w_i,t = wC / n_t` (equal‑weight).
   - If `n_t == 0`, cohort `C_t` is empty; its `wC` is not redistributed unless `redistribute_across_cohorts=true`.
3. Cohort carry and overlap
   - Each cohort `C_s` (formed at month s) remains eligible for months `s, s+1, ..., s+K‑1` (K rebalances).
   - At each month u, the portfolio is the union of active cohorts `{C_s | s in [u‑K+1, u]}`.
   - Within each active cohort at u, drop names that violate `exclude_on_missing_price` (no month‑end price/return) or other hard exclusions; renormalize remaining names to sum to `wC = 1/K` if `renormalize_within_cohort=true`.
4. Portfolio aggregation at u
   - Total target weight per name is the sum of its weights across active cohorts at u.
   - If active cohorts < K (startup period) or any cohort is empty after exclusions, total invested weight `< 1`; the remainder is implicit cash unless `redistribute_across_cohorts=true` (not default).
5. Trades and turnover
   - Compute trades as `trade_dW = target_weight_u − prev_weight_{u‑1}` for each name; non‑held names have `prev_weight=0`.
   - Gross turnover at u is `0.5 * Σ|trade_dW|` across names.
6. Determinism
   - Sorting and rank ties follow M4; selection uses deterministic `decile` or `pct_rank`. No randomness involved.

Edge cases
- If a cohort loses all names at u (e.g., widespread halts), its `wC` becomes cash; no cross‑cohort redistribution by default.
- Tickers reappearing after a halt remain in their original cohort only if they have a valid month‑end price at that month; otherwise they contribute zero for that month.
- Early months (<K) naturally have `n_active_cohorts < K`.

---

## Module and API Design
Add `src/portfolio.py`.

- `select_winners(signals: pd.DataFrame, selection: str = "top_decile", long_decile: int = 10, top_quantile: float = 0.1) -> pd.DataFrame`
  - Input: momentum signals with `['month_end','ticker','valid','decile','pct_rank']`.
  - Output: `['month_end','ticker']` of winners per month (plus optional `rank_cols`).

- `build_overlapping_portfolio(winners: pd.DataFrame, k_months: int, renorm_within: bool = True, exclude_on_missing_price: bool = True) -> pd.DataFrame`
  - Returns holdings with columns described in Outputs.
  - Assumes monthly grid keyed by `month_end`; leverages M4 calendar conventions.

- `holdings_to_trades(holdings: pd.DataFrame) -> pd.DataFrame`
  - Aggregates weights by `month_end,ticker` and computes `prev_weight`, `target_weight`, `trade_dW`, `side`.

- `compute_portfolio(cfg: dict | DataConfig, signals_df: pd.DataFrame | None = None, write: bool = True, out_holdings: str = "data/clean/portfolio_holdings.parquet", out_trades: str | None = "data/clean/portfolio_trades.parquet", out_summary: str | None = None) -> pd.DataFrame`
  - Orchestrator: load `momentum.parquet` if `signals_df` is None; call `select_winners`, `build_overlapping_portfolio`, persist outputs.

Notes
- Use absolute imports (`from src.portfolio import compute_portfolio`).
- Keep pure functions (selection, construction); do I/O only in the orchestrator.

---

## Configuration (Pydantic)
Extend the existing config model with a `portfolio` section:

```yaml
portfolio:
  k_months: 6                 # >=1
  selection: top_decile       # or: top_quantile
  long_decile: 10             # used when selection=top_decile
  top_quantile: 0.10          # used when selection=top_quantile
  renormalize_within_cohort: true
  redistribute_across_cohorts: false
  exclude_on_missing_price: true
  calendar: union             # inherit from signals if omitted
```

Validation
- `k_months >= 1`.
- If `selection=top_decile`, require `long_decile in [1..n_deciles]` and `decile` exists in signals.
- If `selection=top_quantile`, require `0 < top_quantile <= 1` and `pct_rank` exists.

Backward compatibility: If `portfolio` omitted, default to `k_months=6`, `selection=top_decile`, `long_decile=10`.

---

## CLI (Optional)
Add `scripts/compute_portfolio.py`:
- Args: `-c/--config` (default `config/data.yml`), `--dry-run`.
- Behavior: loads signals parquet, builds holdings/trades, writes outputs, prints summary (`months processed`, `avg holdings`, `avg turnover`).
- Usage:
  - `poetry run python scripts/compute_portfolio.py -c config/data.yml`

---

## Tests
Create `tests/test_portfolio.py` with focused, deterministic tests.

- Unit: winner selection
  - Given a month with deciles 1..10, `selection=top_decile` yields only D10; `top_quantile=0.2` yields top 20% by `pct_rank`.
- Unit: cohort sizing
  - With `K=3` and 3 winners at formation, each `w_i = 1/3 * 1/3`; portfolio sum equals `1/3` when only one cohort exists.
- Unit: overlap and decay
  - Form cohorts at `t, t+1, t+2`; at `t+2`, total target weight sums to 1 (three cohorts), per‑cohort equals 1/3.
- Unit: renormalization on drop
  - If a name drops from a cohort, remaining names renormalize within that cohort so that the cohort still sums to `1/K`; portfolio sum never exceeds 1.
- Unit: empty cohort is cash
  - When a cohort becomes empty, portfolio invested weight `< 1`; verify `cash_weight > 0` in summary and no redistribution (default).
- Integration: e2e from signals
  - Small synthetic `momentum.parquet` (2‑3 months, `K=2`) → holdings/trades written, schemas match, spot weights correct.

Testing helpers
- Use absolute imports from `src`.
- Use `tmp_path` for any temp I/O; keep tests fast and deterministic.

---

## Acceptance Criteria
- Config schema accepts/validates `portfolio.*` with defaults and constraints.
- Functionality:
  - Winner selection produces expected sets under both `top_decile` and `top_quantile`.
  - Holdings reflect K‑month overlap; cohorts live exactly K months; weights per cohort sum to `1/K`.
  - Renormalization within cohorts works on drops; total portfolio weight ≤ 1 with equality once K cohorts active and non‑empty.
  - Trades computed as month‑over‑month deltas; turnover reported.
  - Outputs written to `data/clean/portfolio_holdings.parquet` (+ optional trades/summary).
- Quality:
  - `poetry run pytest -k portfolio -q` passes for new tests.
  - Docstrings and type hints present in new functions.
  - No changes to unrelated modules/tests.

---

## Integration with Previous Milestones
- M4: Consumes `data/clean/momentum.parquet`; relies on `decile`/`pct_rank` and `valid` flags.
- M3: Uses the same monthly calendar conventions; no need to recompute returns here.
- M2: Names filtered upstream remain absent; if `hard_errors` are excluded upstream, they do not enter selection or carry.
- M1: No additional ingest required; operate on clean parquet outputs.

---

## Non‑Functional Requirements
- Performance: vectorized pandas; portfolio build for thousands of names over 15+ years finishes in seconds/minutes on a laptop.
- Determinism: identical inputs/config produce identical holdings and trades.
- Robustness: explicit `cash_weight` capture; safe handling of empty cohorts and missing data.

---

## Implementation Notes
- Define `cohort_id = (cohort_start rank modulo K)` to simplify joins and diagnostics.
- Keep cohort weight `wC = 1/K` constant where possible; do not shift weight between cohorts unless explicitly configured.
- If needed, join to monthly closes to enforce `exclude_on_missing_price`; otherwise rely on presence in signals grid per month.
- Log how many names enter each cohort and how many survive each month for auditability.

---

## Deliverables
- Code: `src/portfolio.py` with APIs above; minimal additions to config model.
- CLI: `scripts/compute_portfolio.py` (optional).
- Tests: `tests/test_portfolio.py` with unit and e2e coverage.
- Data: `data/clean/portfolio_holdings.parquet` (+ optional trades/summary) produced by tests/CLI.
- Docs: This `m_5.md` and function docstrings.

---

