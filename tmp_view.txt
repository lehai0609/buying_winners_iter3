# M7: Backtesting Engine

## Purpose
Turn monthly weights and costed trades into gross and net PnL time series with correct timing and Vietnam-specific trading constraints. Ensure no look-ahead, deterministic results, and clear audit trails for executions and costs.

## Objectives
- Implement monthly rebalancing with execution lag (e.g., T+1) and optional T+2 settlement handling.
- Simulate daily and monthly PnL from target weights, applying M6 trading costs on rebalance days.
- Enforce practical constraints: halts (no trade), price limits (+/-7% HOSE; configurable), and renormalization across tradable names.
- Produce reproducible outputs: daily equity/returns (gross/net), monthly summaries, daily holdings, and execution logs.

## Scope
- In-scope: execution timing (lag), daily path simulation, cost application (from M6), halts/price-limit handling, renormalization, outputs, tests, docs, optional CLI.
- Out-of-scope: intraday scheduling and partial execution across multiple days, borrow/shorting, financing and cash drag modeling beyond simple settlement lag.

---

## Inputs and Outputs

### Inputs
- `data/clean/portfolio_holdings.parquet` (from M5): monthly target weights by `[month_end, ticker]` with columns at least `weight` (and optional cohort diagnostics).
- `data/clean/portfolio_trades_costed.parquet` (from M6): monthly trades by `[month_end, ticker]` with `prev_weight`, `target_weight`, `trade_dW`, `total_cost_bps` (+ fee/slip/impact breakdowns).
- `data/clean/ohlcv.parquet` (from M1): daily OHLCV to derive daily returns and detect halts/limits; MultiIndex `[date, ticker]` with `open, high, low, close, volume`.
- `config/backtest.yml` (or fields under `config/data.yml` until split): execution timing, price source, limit/halts behavior, calendar.

Notes
- Execution price source is a modeling choice; default to next-day open when available, else close-to-close with cost adjustment.
- If `open` is missing for a day/name, fall back to using daily close-to-close returns; still apply costs on the rebalance day.

### Outputs
- Parquet: `data/clean/backtest_daily.parquet` (index `date`)
  - `nav` (float; normalized to 1.0 at first date)
  - `ret_gross_d` (float), `ret_net_d` (float)
  - `turnover_d` (float; optional), `cash_weight` (float)
- Parquet: `data/clean/backtest_monthly.parquet` (index `month_end`)
  - `ret_gross_m`, `ret_net_m`, `gross_turnover_m`, `n_holdings`, `n_tradable`, `n_halts`, `n_limit_skips`
- Parquet (optional): `data/clean/holdings_daily.parquet` indexed by `[date, ticker]` with columns `weight` (post-trade, effective for that day) and `tradable` (bool).
- Parquet (optional): `data/clean/executions.parquet` indexed by `[rebalance_date, ticker]` with `prev_weight`, `target_weight`, `filled_weight`, `trade_dW`, `filled_dW`, `skipped_reason` (`halt`|`limit`|`none`), `cost_bps_applied`.

---

## Algorithm Details
1. Calendars and rebalancing dates
   - Derive month-ends from daily grid (`returns.monthly_calendar`); let `t` denote a month-end.
   - Determine execution date `t_exec = t + lag_days` using trading days from the chosen calendar (`union` or `vnindex`).
2. Daily returns and constraints
   - Compute daily close-to-close returns `ret_d` from OHLCV; if `price_limit_pct` configured, cap individual name returns to `[-price_limit_pct, +price_limit_pct]` for modeling purposes.
   - Mark `tradable_{i,d} = (volume>0 and not missing price)`; if not tradable on `t_exec`, the order for name `i` is skipped.
3. Weight path and executions
   - Before `t_exec`, portfolio holds previous effective weights. On `t_exec`, attempt to move from `prev_weight` to `target_weight` per name.
   - If `skip_on_halt=true` and `tradable_{i,t_exec}=False`, set `filled_weight_{i,t_exec} = prev_weight_{i,t_exec}` and mark `skipped_reason='halt'`.
   - If `skip_on_limit=true` and `|ret_{i,t_exec}| >= price_limit_pct`, skip and mark `skipped_reason='limit'`.
   - For names not skipped, set `filled_weight = target_weight` (single-day execution model). After fills, renormalize filled weights across tradable names so that invested weight <= 1; residual is cash.
4. Apply trading costs (from M6)
   - For each `[t, i]`, take `total_cost_bps_{i,t}` from `portfolio_trades_costed`. Convert to a portfolio-level daily return drag on `t_exec`: `cost_ret_d = - sum_i(total_cost_bps_{i,t} / 1e4)` (already in weight-space bps if M6 scaled by `|dW|`).
   - If some names are skipped, scale costs by actual `filled_dW` vs `trade_dW` (i.e., only pay for executed portion).
5. Daily PnL simulation
   - For each day `d`, compute gross portfolio return as `ret_gross_d = sum_i weight_{i,d-1} * ret_{i,d}` where `weight_{i,d-1}` is the effective end-of-day weight from prior day; on `t_exec`, apply cost drag: `ret_net_d = ret_gross_d + cost_ret_d`, else `ret_net_d = ret_gross_d`.
   - Update `nav_d = nav_{d-1} * (1 + ret_net_d)`; set `holdings_daily` to effective weights after execution for day `d+1`.
6. Monthly aggregation
   - Aggregate daily to month-end for `backtest_monthly.parquet` including gross/net returns, turnover (from `|dW|` at month-ends), counts of halts/limit skips, and average holdings.

Edge cases
- Startup months with fewer than K cohorts yield `cash_weight > 0`; trades are still executed when cohorts arrive.
- If a name delists intra-month (missing prices), carry last effective weight forward only if price is missing; otherwise drop and renormalize.
- Missing `open` prices: fallback to close-to-close returns with the same cost application.

Determinism
- All computations are pure functions of inputs/config. No randomness. Lags and caps are explicit and tested.

---

## Config Changes (Pydantic)
Add a `backtest` section (initially in `config/data.yml`; may move to `config/backtest.yml`).

Fields and defaults
- `backtest.initial_capital` (float > 0; default `1_000_000_000` VND): used only for diagnostics if converting weights to notional.
- `backtest.calendar` (enum: `union`|`vnindex`; default `union`): daily grid for returns and lagging.
- `backtest.execution.lag_days` (int >= 0; default `1`): days after month-end to execute.
- `backtest.execution.price` (enum: `open`|`close`|`vwap_proxy`; default `open`).
- `backtest.execution.skip_on_halt` (bool; default `true`).
- `backtest.execution.price_limit_pct` (float in (0,1]; default `0.07`): cap used for limit modeling.
- `backtest.execution.skip_on_limit` (bool; default `true`).
- `backtest.costs.apply` (bool; default `true`): subtract `total_cost_bps` from M6 on execution day.
- `backtest.costs.scale_by_fill` (bool; default `true`): when orders are skipped, scale costs by `filled_dW / trade_dW`.

Validation
- `lag_days >= 0`; `0 < price_limit_pct <= 1`.
- If `execution.price='open'`, require `open` in OHLCV; otherwise allow fallback with a clear warning in logs.

Backward compatibility
- If `backtest` omitted, default to `lag_days=1`, `price='open'`, `skip_on_halt=true`, `skip_on_limit=true`, and `apply=true` so existing flows run.

---

## APIs and I/O
Add `src/backtest.py`:

```python
def build_rebalance_schedule(month_ends: pd.DatetimeIndex, lag_days: int, calendar: pd.DatetimeIndex) -> pd.Series:
    """Map each month_end to execution date t_exec on the provided trading calendar."""

def apply_executions(weights_m: pd.DataFrame, trades_costed_m: pd.DataFrame,
                     ohlcv_d: pd.DataFrame, cfg: BacktestConfig) -> tuple[pd.DataFrame, pd.DataFrame]:
    """Return (executions, holdings_daily_stub). Executions include filled weights and skip reasons."""

def simulate_path(returns_d: pd.DataFrame, executions: pd.DataFrame,
                  holdings_daily_stub: pd.DataFrame, cfg: BacktestConfig) -> dict:
    """Return dict with DataFrames: daily, monthly, holdings_daily (final)."""
```

CLI (optional): `scripts/run_backtest.py`
- Args: `-c/--config` (default `config/data.yml`), `--dry-run`.
- Behavior: loads inputs, builds schedule, applies executions and costs, simulates path, writes outputs, prints summary (years, CAGR gross/net, avg turnover).

---

## Tests
Create `tests/test_backtest.py` with deterministic unit and integration cases.

- Unit: execution lag
  - With `lag_days=1`, returns on the first day after month-end accrue to prior weights; trades apply on day 1.
- Unit: no costs vs costs
  - With `apply=false`, `ret_net == ret_gross`; with `apply=true`, `ret_net = ret_gross - sum(costs_bps)/1e4` on exec days.
- Unit: halts
  - If `volume=0` on `t_exec`, order is skipped and weights renormalize across tradable names; cash captures remainder.
- Unit: price limits
  - When `|ret_d| >= price_limit_pct` and `skip_on_limit=true`, order skipped; if `skip_on_limit=false`, trade fills and PnL uses capped return.
- Unit: startup cash
  - When active cohorts < K, `cash_weight > 0` and sums check out; once K cohorts active (non-empty), invested weight ~ 1.
- Integration: toy e2e
  - Tiny dataset with 2-3 names and 3 months: equity curve matches hand calculation within 1bp; monthly outputs and execution logs match expected schemas.

Testing helpers
- Keep fixtures tiny; use `tmp_path` for I/O; assert schemas and value checks at key dates (rebalance, startup, halt/limit days).

---

## Acceptance Criteria
- Config model validates `backtest.*` fields with sensible defaults.
- Daily and monthly outputs written with documented schemas; deterministic across runs.
- Execution timing correct (lag applied); halts and limits respected per config; renormalization keeps invested weight <= 1 with residual to cash.
- Costs from M6 applied only on executed portions and only on execution days; reconciliation holds: `gross - costs = net` on those days.
- `poetry run pytest -k backtest -q` passes for new tests.

---

## Integration with Previous Milestones
- M5: Consumes `portfolio_holdings.parquet` (weights) and optional `portfolio_trades.parquet`.
- M6: Consumes `portfolio_trades_costed.parquet` for `total_cost_bps` and scales by actual fills.
- M3/M4: Reuses monthly calendar and signal timing conventions (skip days already applied in signals).

---

## Non-Functional Requirements
- Performance: vectorized pandas; multi-year daily simulation for thousands of names finishes within minutes on a laptop.
- Determinism: no RNG; explicit lags; stable sorting/joins.
- Robustness: graceful handling of missing data; explicit flags for halts/limit skips; no crashes on empty cohorts.

---

## Implementation Notes
- Weight-space simulation avoids share/unit tracking; apply costs as bps-return drags on execution days.
- Use `union` trading calendar by default to ensure trades occur on the next available market day even if some names are missing.
- Keep constraint logic (halts/limits) isolated for easier testing and future extension (e.g., participation caps, partial fills).

---

## Deliverables
- Code: `src/backtest.py` with APIs above; config model updates.
- CLI: `scripts/run_backtest.py` (optional).
- Tests: `tests/test_backtest.py` with unit and integration coverage.
- Data: `data/clean/backtest_daily.parquet`, `data/clean/backtest_monthly.parquet` (+ optional holdings/executions detail).
- Docs: This `m_7.md` and function docstrings.

